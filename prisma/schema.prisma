generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  // Uses connection pooling
  url       = env("POSTGRES_PRISMA_URL")
  // Uses direct connection, ⚠️ make sure to keep this to `POSTGRES_URL_NON_POOLING`
  // or you'll have dangling databases from migrations
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  metrics                 Metric[]
  data_source_connections DataSourceConnection[]
  manual_data_sources     ManualDataSource[]

  name     String
  email    String @unique
  password String
  role     String
}

model Metric {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  connections MetricConnection[]
  user        User               @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id     String

  name          String
  format        String  @default("number") // number / money / percentage
  show_on_grid  Boolean @default(false)
  show_on_table Boolean @default(false)
}

model MetricConnection {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  metric    Metric @relation(fields: [metric_id], references: [id], onDelete: Cascade)
  metric_id String

  //for manual data
  manual_entries        ManualEntry[]
  manual_data_source    ManualDataSource? @relation(fields: [manual_data_source_id], references: [id], onDelete: Cascade)
  manual_data_source_id String?

  // for imported data
  data_source_connection    DataSourceConnection? @relation(fields: [data_source_connection_id], references: [id], onDelete: Cascade)
  data_source_connection_id String?
  metric_key                String?
}

model DataSource {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  connections DataSourceConnection[]

  name   String
  key    String  @unique
  hidden Boolean @default(true)
}

model DataSourceConnection {
  id                 String             @id @default(uuid())
  created_at         DateTime           @default(now())
  updated_at         DateTime           @updatedAt
  metric_connections MetricConnection[]

  user            User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id         String
  data_source     DataSource @relation(fields: [data_source_key], references: [key])
  data_source_key String

  account_name  String  @default("")
  property_name String  @default("")
  access_token  String?
  expiry_date   BigInt?
  id_token      String?
  refresh_token String?
  scope         String?
  token_type    String?
}

model ManualDataSource {
  id                 String             @id @default(uuid())
  created_at         DateTime           @default(now())
  updated_at         DateTime           @updatedAt
  entries            ManualEntry[]
  metric_connections MetricConnection[]

  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String

  key  String // marketing-agency / graphic-design etc.
  name String
}

model ManualEntry {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  metric_connection     MetricConnection @relation(fields: [metric_connection_id], references: [id], onDelete: Cascade)
  metric_connection_id  String
  manual_data_source    ManualDataSource @relation(fields: [manual_data_source_id], references: [id], onDelete: Cascade)
  manual_data_source_id String

  value      BigInt
  entry_date String @default("")
}
